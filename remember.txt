
    fn contains_point(&self, p: egui::Pos2) -> bool {
        self.points.windows(2).any(|window| {
            let s = window[0];
            let e = window[1];
            let w = self.stroke.width;
            // Line::segment_contains_point(s, e, w, p)
            Self::segment_contains_point(s, e, w, p)
        })
    }

    fn orientation(p: egui::Pos2, q: egui::Pos2, r: egui::Pos2) -> i32 {
        let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y * q.y);
        if val == 0.0 {
            0
        } else if val > 0.0 {
            1
        } else {
            0
        }
    }

    fn on_segment(p: egui::Pos2, q: egui::Pos2, r: egui::Pos2) -> bool {
        q.x >= p.x.min(r.x) && q.x <= p.x.max(r.x) && q.y >= p.y.min(r.y) && q.y <= p.y.max(r.y)
    }

    fn segment_intersects_segment(
        a: egui::Pos2,
        b: egui::Pos2,
        c: egui::Pos2,
        d: egui::Pos2,
    ) -> bool {
        let o1 = Self::orientation(a, b, c);
        let o2 = Self::orientation(a, b, d);
        let o3 = Self::orientation(c, d, a);
        let o4 = Self::orientation(c, d, b);
        if o1 != o2 && o3 != o4 {
            return true;
        }
        if o1 == 0 && Self::on_segment(a, c, b) {
            return true;
        }
        if o2 == 0 && Self::on_segment(a, d, b) {
            return true;
        }
        if o3 == 0 && Self::on_segment(c, a, d) {
            return true;
        }
        if o4 == 0 && Self::on_segment(c, b, d) {
            return true;
        }

        false
    }
